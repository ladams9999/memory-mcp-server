"""Tests for the Memory data model."""

import pytest
from datetime import datetime, timezone
from uuid import UUID

from pydantic import ValidationError

from mcp_memory_server.models.memory import Memory


class TestMemoryCreation:
    """Test Memory model creation and default values."""
    
    def test_memory_creation_with_required_fields_only(self):
        """Test creating a memory with only required fields."""
        memory = Memory(
            content="Test memory content",
            context="test_context"
        )
        
        assert memory.content == "Test memory content"
        assert memory.context == "test_context"
        assert memory.metadata == {}
        assert memory.embedding is None
        assert isinstance(memory.timestamp, datetime)
        assert memory.id is not None
        
    def test_memory_creation_with_all_fields(self):
        """Test creating a memory with all fields provided."""
        test_timestamp = datetime.now(timezone.utc)
        test_metadata = {"source": "test", "confidence": 0.95}
        test_embedding = [0.1, 0.2, 0.3, 0.4]
        
        memory = Memory(
            id="custom-id-123",
            content="Test memory content",
            context="test_context",
            metadata=test_metadata,
            embedding=test_embedding,
            timestamp=test_timestamp
        )
        
        assert memory.id == "custom-id-123"
        assert memory.content == "Test memory content"
        assert memory.context == "test_context"
        assert memory.metadata == test_metadata
        assert memory.embedding == test_embedding
        assert memory.timestamp == test_timestamp
        
    def test_memory_id_generation(self):
        """Test that UUID7 IDs are generated by default."""
        memory1 = Memory(content="Test 1", context="test")
        memory2 = Memory(content="Test 2", context="test")
        
        # IDs should be different
        assert memory1.id != memory2.id
        
        # IDs should be valid UUIDs (will raise ValueError if invalid)
        UUID(memory1.id)
        UUID(memory2.id)
        
    def test_memory_timestamp_generation(self):
        """Test that timestamps are generated by default."""
        before = datetime.utcnow()
        memory = Memory(content="Test", context="test")
        after = datetime.utcnow()
        
        assert before <= memory.timestamp <= after


class TestMemoryValidation:
    """Test Memory model field validation."""
    
    def test_content_required(self):
        """Test that content field is required."""
        with pytest.raises(ValidationError) as exc_info:
            Memory(context="test")
        
        errors = exc_info.value.errors()
        assert any(error["loc"] == ("content",) for error in errors)
        
    def test_context_required(self):
        """Test that context field is required."""
        with pytest.raises(ValidationError) as exc_info:
            Memory(content="test content")
        
        errors = exc_info.value.errors()
        assert any(error["loc"] == ("context",) for error in errors)
        
    def test_content_min_length_validation(self):
        """Test content minimum length validation."""
        with pytest.raises(ValidationError) as exc_info:
            Memory(content="", context="test")
        
        errors = exc_info.value.errors()
        assert any(
            error["loc"] == ("content",) and "at least 1 character" in str(error["msg"])
            for error in errors
        )
        
    def test_content_max_length_validation(self):
        """Test content maximum length validation."""
        long_content = "x" * 10001  # Exceeds 10000 character limit
        
        with pytest.raises(ValidationError) as exc_info:
            Memory(content=long_content, context="test")
        
        errors = exc_info.value.errors()
        assert any(
            error["loc"] == ("content",) and "at most 10000 characters" in str(error["msg"])
            for error in errors
        )
        
    def test_context_min_length_validation(self):
        """Test context minimum length validation."""
        with pytest.raises(ValidationError) as exc_info:
            Memory(content="test", context="")
        
        errors = exc_info.value.errors()
        assert any(
            error["loc"] == ("context",) and "at least 1 character" in str(error["msg"])
            for error in errors
        )
        
    def test_context_max_length_validation(self):
        """Test context maximum length validation."""
        long_context = "x" * 256  # Exceeds 255 character limit
        
        with pytest.raises(ValidationError) as exc_info:
            Memory(content="test", context=long_context)
        
        errors = exc_info.value.errors()
        assert any(
            error["loc"] == ("context",) and "at most 255 characters" in str(error["msg"])
            for error in errors
        )
        
    def test_valid_content_lengths(self):
        """Test valid content lengths at boundaries."""
        # Minimum valid length
        memory1 = Memory(content="x", context="test")
        assert memory1.content == "x"
        
        # Maximum valid length
        max_content = "x" * 10000
        memory2 = Memory(content=max_content, context="test")
        assert memory2.content == max_content
        
    def test_valid_context_lengths(self):
        """Test valid context lengths at boundaries."""
        # Minimum valid length
        memory1 = Memory(content="test", context="x")
        assert memory1.context == "x"
        
        # Maximum valid length
        max_context = "x" * 255
        memory2 = Memory(content="test", context=max_context)
        assert memory2.context == max_context


class TestMemoryMethods:
    """Test Memory model custom methods."""
    
    def test_has_embedding_with_none(self):
        """Test has_embedding returns False when embedding is None."""
        memory = Memory(content="test", context="test", embedding=None)
        assert memory.has_embedding() is False
        
    def test_has_embedding_with_empty_list(self):
        """Test has_embedding returns False when embedding is empty list."""
        memory = Memory(content="test", context="test", embedding=[])
        assert memory.has_embedding() is False
        
    def test_has_embedding_with_values(self):
        """Test has_embedding returns True when embedding has values."""
        memory = Memory(content="test", context="test", embedding=[0.1, 0.2, 0.3])
        assert memory.has_embedding() is True
        
    def test_str_representation(self):
        """Test string representation of Memory."""
        memory = Memory(
            id="test-id-123",
            content="This is a test memory with some content",
            context="test_context"
        )
        
        str_repr = str(memory)
        assert "test-id-" in str_repr
        assert "test_context" in str_repr
        assert "This is a test memory with some content" in str_repr
        
    def test_repr_representation(self):
        """Test developer representation of Memory."""
        memory = Memory(
            id="test-id-123",
            content="This is a test memory",
            context="test_context",
            embedding=[0.1, 0.2]
        )
        
        repr_str = repr(memory)
        assert "Memory(" in repr_str
        assert "id='test-id-123'" in repr_str
        assert "context='test_context'" in repr_str
        assert "has_embedding=True" in repr_str
        assert memory.timestamp.isoformat() in repr_str


class TestMemorySerialization:
    """Test Memory model serialization and deserialization."""
    
    def test_to_dict(self):
        """Test converting Memory to dictionary."""
        test_timestamp = datetime(2025, 7, 23, 23, 30, 0, tzinfo=timezone.utc)
        test_metadata = {"source": "test", "confidence": 0.95}
        test_embedding = [0.1, 0.2, 0.3]
        
        memory = Memory(
            id="test-id-123",
            content="Test memory content",
            context="test_context",
            metadata=test_metadata,
            embedding=test_embedding,
            timestamp=test_timestamp
        )
        
        result = memory.to_dict()
        
        assert result == {
            "id": "test-id-123",
            "content": "Test memory content",
            "context": "test_context",
            "metadata": test_metadata,
            "embedding": test_embedding,
            "timestamp": "2025-07-23T23:30:00+00:00"
        }
        
    def test_to_dict_with_none_embedding(self):
        """Test to_dict with None embedding."""
        memory = Memory(content="test", context="test", embedding=None)
        result = memory.to_dict()
        
        assert result["embedding"] is None
        assert "timestamp" in result
        assert isinstance(result["timestamp"], str)
        
    def test_from_dict_basic(self):
        """Test creating Memory from dictionary."""
        data = {
            "id": "test-id-123",
            "content": "Test memory content",
            "context": "test_context",
            "metadata": {"source": "test"},
            "embedding": [0.1, 0.2, 0.3],
            "timestamp": "2025-07-23T23:30:00+00:00"
        }
        
        memory = Memory.from_dict(data)
        
        assert memory.id == "test-id-123"
        assert memory.content == "Test memory content"
        assert memory.context == "test_context"
        assert memory.metadata == {"source": "test"}
        assert memory.embedding == [0.1, 0.2, 0.3]
        assert memory.timestamp == datetime(2025, 7, 23, 23, 30, 0, tzinfo=timezone.utc)
        
    def test_from_dict_with_z_timestamp(self):
        """Test from_dict with Z-suffix timestamp (ISO format)."""
        data = {
            "content": "Test memory",
            "context": "test_context",
            "timestamp": "2025-07-23T23:30:00Z"
        }
        
        memory = Memory.from_dict(data)
        assert memory.timestamp == datetime(2025, 7, 23, 23, 30, 0, tzinfo=timezone.utc)
        
    def test_from_dict_with_datetime_object(self):
        """Test from_dict when timestamp is already a datetime object."""
        test_timestamp = datetime(2025, 7, 23, 23, 30, 0, tzinfo=timezone.utc)
        data = {
            "content": "Test memory",
            "context": "test_context",
            "timestamp": test_timestamp
        }
        
        memory = Memory.from_dict(data)
        assert memory.timestamp == test_timestamp
        
    def test_roundtrip_serialization(self):
        """Test that to_dict -> from_dict preserves data."""
        original = Memory(
            content="Test memory content",
            context="test_context",
            metadata={"source": "test", "tags": ["important"]},
            embedding=[0.1, 0.2, 0.3, 0.4]
        )
        
        # Convert to dict and back
        data = original.to_dict()
        reconstructed = Memory.from_dict(data)
        
        # Compare all fields
        assert reconstructed.id == original.id
        assert reconstructed.content == original.content
        assert reconstructed.context == original.context
        assert reconstructed.metadata == original.metadata
        assert reconstructed.embedding == original.embedding
        assert reconstructed.timestamp == original.timestamp
        
    def test_from_dict_missing_timestamp(self):
        """Test from_dict when timestamp is not provided."""
        data = {
            "content": "Test memory",
            "context": "test_context"
        }
        
        # Should use default timestamp generation
        before = datetime.utcnow()
        memory = Memory.from_dict(data)
        after = datetime.utcnow()
        
        assert before <= memory.timestamp <= after


class TestMemoryEdgeCases:
    """Test Memory model edge cases and error conditions."""
    
    def test_metadata_as_none(self):
        """Test metadata field when not provided (uses default)."""
        # This should work because metadata has default_factory=dict
        memory = Memory(content="test", context="test")
        # Should use default empty dict
        assert memory.metadata == {}
        
    def test_metadata_with_complex_data(self):
        """Test metadata with complex nested data."""
        complex_metadata = {
            "source": "conversation",
            "confidence": 0.95,
            "tags": ["important", "user_preference"],
            "nested": {
                "level1": {
                    "level2": "deep_value"
                }
            },
            "numbers": [1, 2, 3],
            "boolean": True
        }
        
        memory = Memory(
            content="test",
            context="test",
            metadata=complex_metadata
        )
        
        assert memory.metadata == complex_metadata
        
    def test_embedding_with_different_sizes(self):
        """Test embedding with various vector sizes."""
        # Small embedding
        memory1 = Memory(content="test", context="test", embedding=[0.1])
        assert memory1.has_embedding() is True
        
        # Large embedding (typical for real embeddings)
        large_embedding = [0.1] * 1536  # OpenAI embedding size
        memory2 = Memory(content="test", context="test", embedding=large_embedding)
        assert memory2.has_embedding() is True
        assert memory2.embedding is not None
        assert len(memory2.embedding) == 1536
        
    def test_unicode_content_and_context(self):
        """Test Memory with Unicode characters."""
        memory = Memory(
            content="Test with émojis 🚀 and unicode: 中文",
            context="unicode_tëst_çontext"
        )
        
        assert "émojis 🚀" in memory.content
        assert "中文" in memory.content
        assert "tëst_çontext" in memory.context


class TestMemoryComparison:
    """Test Memory model comparison and equality."""
    
    def test_memory_equality_with_same_data(self):
        """Test that memories with same data are considered equal."""
        timestamp = datetime.now(timezone.utc)
        
        memory1 = Memory(
            id="same-id",
            content="same content",
            context="same context",
            timestamp=timestamp
        )
        
        memory2 = Memory(
            id="same-id",
            content="same content",
            context="same context",
            timestamp=timestamp
        )
        
        # Pydantic models support equality comparison
        assert memory1 == memory2
        
    def test_memory_inequality_with_different_data(self):
        """Test that memories with different data are not equal."""
        memory1 = Memory(content="content1", context="context1")
        memory2 = Memory(content="content2", context="context2")
        
        assert memory1 != memory2
